# Список вопросов к экзамену по ЭВМ, мехмат, 3 семестр, 2020.
## Вопросы по курсу "Алгоритмы и алгоритмические языки".

1.    Что такое дополнительный код?  
для представления отрицательного числа берется представление его модуля, все биты инвертируются, к результату прибавляется 1

2.    Какое отношение  кольцо вычетов имеет к дополнительному коду?  
Представление чисел в дополнительном коде эквивалентно представлению чисел в кольце вычетов по модулю 2^n, где n – количество бит в двоичном представлении числа.
Для доказательства утверждения достаточно доказать, что вышеприведенное определение отрицательного числа в дополнительном коде эквивалентно следующему: пусть x>0, то -x получается с помощью операции 2n-x. В исходном определении число -x получается из x>0 следующим образом: сначала производится инверсия числа, что эквивалентно операции 2^n-x-1. Это следует из того, что (2^n-x-1)+x=2^n-1=числу, состоящему из n единиц, а это возможно только если на месте единичных бит числа 2n-x-1 стоят нули в представлении числа x и наоборот (на  месте нулевых бит числа 2^n-x-1 стоят единицы в представлении числа x). Осталось прибавить 1 и мы получим требуемые 2^n-x.

3.    Каков алгоритм деления на 2 для целого числа в дополнительном коде на уровне бит?  
x = p * 2^dmin
где  p – число с фиксированной точкой в виде x.xxxxx (где x – двоичная цифра; хранятся все указанные биты!).
число 2^-150 уже неотличимо от 0.Если вышеуказанные число получались каждый раз путем деления предыдущего числа на 2, то в результате получения последнего число из 2^-149 мы получили ситуацию underflow – нижнее переполнение.

4.    Какие преимущества у дополнительного кода представления целых чисел по сравнению с прямым кодом?  
Он позволяет заменить операцию вычитания на операцию сложения и сделать операции сложения и вычитания одинаковыми для знаковых и беззнаковых чисел, чем упрощает архитектуру ЭВМ. 

5.    В чем преимущество вещественных чисел с фиксированной точкой над вещественными числами с плавающей точкой?  
Достоинство такой формы – простота и наглядность представления чисел и алгоритмов реализации операций.

6.    В чем преимущество вещественных чисел с плавающей точкой над вещественными числами с фиксированной точкой?  
Относительно большой диапазон представления величин, который проявляется при необходимости представления слишком больших или малых чисел, т.е. точку можно перемещать по разрядной сетке с целью уменьшения или увеличения дробной или целой части вещественного числа.

7.    Что означает фраза "одно вещественное число с плавающей точкой много меньше другого"?  
Проблема сравнения чисел с плавающей точкой на равенство заключается в том, что многие числа не имеют точного представления в двоичной с плавающей запятой. Если сравниваются достаточно далекие числа - с разницей >> машинного эпсилон, то фраза имеет смысл.

8.    Могут ли натуральные числа от 1 до миллиона точно представляться в виде вещественного числа типа float? Ответ обосновать.  
нет. вопрос об индексации массива float'ом. Миллион - это примерно 2^20. float представляется до 7 знаков, сл. не хватит точности.

9.    Определение машинного эпсилон.  
числовое значение, меньше которого невозможно задавать относительную точность для любого алгоритма, возвращающего вещественные числа. Абсолютное значение «машинного эпсилон» зависит от разрядности сетки применяемой ЭВМ, типа (разрядности) используемых при расчетах чисел, и от принятой в конкретном трансляторе структуры представления вещественных чисел (количества бит, отводимых на мантиссу и на порядок). Формально машинный эпсилон обычно определяют как минимальное из чисел ε, для которого 1+ε>1 при машинных расчетах с числами данного типа.

10.   С какой точностью представляется вещественное число в виде вещественного числа с плавающей точкой (если оно не слишком большое)?  
точность float: от 6 до 9 цифр (в основном 7);  
точность double: от 15 до 18 цифр (в основном 16);  
точность long double: 15, 18 или 33 цифры (в зависимости от того, сколько байт занимает тип данных на компьютере).

11.   На основе каких постулатов строится тип NUMBER (Oracle)?

12.   Как правильно выписать условие на языке С, что у квадратного уравнения существует единственное решение?

13.   По каким формулам следует вычислять на языке С корни квадратного уравнения в случае наличия двух корней?

14.   Определение абсолютной ошибки вещественного числа. Теорема о распространении абсолютной ошибки при арифметических операциях.

15.   Определение относительной ошибки вещественного числа. Теорема о распространении относительной ошибки при арифметических операциях.

16.   Связь машинного эпсилон и абсолютной/относительной ошибок представления вещественных чисел с плавающей точкой.

17.   Почему вещественные числа с плавающей точкой могут самопроизвольно меняться в программе?

18.   Почему нельзя сравнивать на равенство вещественные числа с плавающей точкой?

19.   Основные свойства понятия алгоритм?
Алгоритмом m называется формально описанная процедура, имеющая некоторый набор входных данных In(m) и выходных данных Out(m). Вводится некоторый параметр, оценивающий объем входных данных N=N(In(m)).  Будем называть этот параметр размером входных данных.

При создании алгоритма закрепляется некоторый конечный  набор допустимых операций, в терминах которых формулируется алгоритм. От алгоритма требуется его конечность, т.е. мы говорим, что задача решается с помощью некоторого алгоритма, только если для каждого набора входных данных соответствующий набор выходных данных получается с помощью заданного алгоритма за конечное количество допустимых операций.

20.   Что такое время работы алгоритма?
Для оценки времени работы алгоритма с каждой допустимой операцией ассоциируется время ее выполнения. Временем выполнения реализации алгоритма T(m) для определенных начальных данных называется сумма времен выполнения всех операций алгоритма при выполнении данной реализации.

21.   Что значит задача a сводится к задаче b за время O(f(n))? //(В лекциях использовалось время g(N), которое заменил на O(f(n)))
Будем говорить, что задача z1 сводится к задаче z2 за время O(f(n)), если
	входные данные задачи z1, имеющие объем N, могут быть приведены к входным данным задачи z2, при этом входные данные задачи z2 тоже имеют объем N;
	выходные данные задачи z2 могут быть приведены к выходным данным задачи z1,	
и все это за суммарное время O(f(n)) (т.е. суммарное время выполнения алгоритмов приведения = O(f(n))).


22.   Что такое верхняя оценка времени работы алгоритма?
Верхней оценкой времени выполнения алгоритма m называется такая функция F(N), что для любого набора входных данных In(m) размером не более N время выполнения алгоритма не будет превосходить F (N).

23.   Что такое верхняя оценка времени решения задачи?
 Будем говорить, что задача z имеет верхнюю оценку времени решения F (N), если существует алгоритм m с верхней оценкой времени выполнения F (N).

24.   Что такое нижняя оценка времени работы алгоритма?
Нижней оценкой времени выполнения алгоритма m  называется такая функция j(N), что для любого N найдется такой набор входных данных алгоритма размером N, что время работы данного алгоритма на указанных данных будет не меньше j(N).

25.   Что такое нижняя оценка времени решения задачи?Нижней оценкой времени решения задачи z  называется такая функция j(N), что для любого алгоритма, решающего данную задачу,  j(N) будет нижней оценкой времени работы данного алгоритма.
26.   Теорема о взаимосвязи нижних оценок времен решения задач при сведении задач. Формулировка. Идея доказательства.

27.   Теорема о взаимосвязи верхних оценок времен решения задач при сведении задач. Формулировка. Доказательство.

28.   Определение сортировки. Условия существования сортировки.

29.   Теорема о существовании и единственности сортировки.

30.   Сколько операторов сравнения надо определить, чтобы реализовать сортировку?
Достаточно определить 1 оператор "меньше" a<b. При этом "больше" определеляется по симметрии b<a. "Равенство" определяется как не "больше" и не "меньше"

31.   Сортировка пузырьком. Случай оптимальности сортировки пузырьком.

32.   Теорема о верхней оценке времени работы алгоритма сортировки пузырьком в случае когда время обмена местами двух элементов=Θ(|i-j|).

33.   Определения сортировки, основанной на сравнениях.

34.   Чему соответствует одно ребро в дереве решений для задачи сортировки?

35.   Чему соответствует одна вершина в дереве решений для задачи сортировки?

36.   Сколько конечных вершин (листьев) у дерева решений для задачи сортировки? В каком случае?

37.   Формулировка теоремы о верхней оценке времени решения задачи сортировки, основанной на сравнениях.

38.   Формулировка теоремы о нижней оценке времени решения задачи сортировки, основанной на сравнениях.

39.   Можно ли построить сортировку, основанную на сравнениях, которая для любого N будет работать в каких-то случаях быстрее, чем за время O(n log n)?

40.   Привести пример алгоритмов, которые не укладываются в схему алгоритма на основе дерева решения.

41.   Идея алгоритма сортировки слиянием с рекурсией.

42.   Идея алгоритма сортировки слиянием без рекурсии.

43.   Сколько и какой дополнительной памяти требует алгоритм слиянием с рекурсией?

44.   Сколько и какой дополнительной памяти требует алгоритм слиянием без рекурсии?

45.   Теорема об оптимальности алгоритма слияния двух упорядоченных массивов.

46.   Общее описание алгоритма QSort.

47.   Теорема о среднем времени работы алгоритма QSort.

48.   Алгоритм HeapSort.

49.   Теорема об оценке времени работы алгоритма HeapSort.

50.   Определение и основные свойства объекта куча (пирамида) из алгоритма HeapSort.

51.   Теорема о времени работы алгоритма построения пирамиды.

52.   Определение устойчивой сортировки.

53.   Сортировка подсчетом.

54.   Цифровая сортировка.

55.   Для каких данных применима сортировка подсчетом?

56.   Для каких данных применима цифровая сортировка?

57.   Сколько дополнительной памяти требует сортировка подсчетом?

58.   Сколько дополнительной памяти требует цифровая сортировка?

59.   Определение выпуклой оболочки.

60.   Алгоритм Грэхема построения выпуклой оболочки.

61.   Теоремы о верхней оценке решения задачи построения выпуклой оболочки в R2 в рамках алгоритмов, основанных на сравнениях.

62.   Теоремы о нижней оценке решения задачи построения выпуклой оболочки в R2 в рамках алгоритмов, основанных на сравнениях.

63.   Определение диаграммы Вороного.

64.   Теорема о существовании диаграммы Вороного.

65.   Определение триангуляции Делоне.

66.   Связь диаграммы Вороного и триангуляции Делоне.

67.   Поиск порядковой статистики за линейное время в среднем.

68.   Идея поиска порядковой статистики за линейное время в худшем случае.

69.   Поиск порядковой статистики последовательности целых чисел {ai} (i=1,…,n) за линейное время для случая ai < O(n). Основные идеи.

70.   Задача поиска порядковой статистики в большой окрестности каждой точки серого изображения.

71.   Регулярные выражения в UNIX. Простые примеры использования.

72.   bash: Что такое локальные и импортируемые переменные?

73.   bash: Синтаксис цикла for

74.   bash: примеры вычисления арифметических выражений.

75.   bash: примеры вычисления логических выражений.

76.    Понятия палитры, битовых плоскостей, true color в изображениях.

77.   Основные идеи формата изображения BMP.

78.   C++. Понятия инкапсуляции и полиморфизма.

79.   C++. Понятия простых и сложных классов.

80.   С++. Чем отличаются структуры от классов?

81.   Статические элементы структур/классов. Синтаксис.

82.   C++. Конструкторы. Синтаксис. Вызов для подобъектов.

83.   C++. Деструкторы. Синтаксис.  Вызов для подобъектов.

84.   С++. Почему присваивание по умолчанию нельзя использовать в сложных классах?

85.   С++. Зачем нужен конструктор копирования?

86.   C++. Переопределение бинарных операторов. Синтаксис.

87.   C++. Переопределение унарных операторов. Синтаксис.

88.   C++. Переопределение операторов преобразования типа. Синтаксис.

89.   C++. Какие операторы не могут переопределяться как глобальные функции?

90.   C++. Оператор запятая. Использование.

91.   C++. Примеры сложных неявных преобразований типов.

92.   C++. Отведение памяти.

93.   C++. Конструкторы копирования. Примеры использования.

94.   C++. Параметры по умолчанию. Синтаксис.

95.   C++. Исключения.

96.   С++. SEH-исключения Microsoft.

97.   C++. Возможность продолжения работы программы при выбросе исключения с места выброса исключения.

98.   С++. Дружественные функции/классы. Примеры.

99.   C++. Ввод/вывод на экран. Общий синтаксис.

100.    C++. Ввод/вывод на экран. Манипуляторы.

101.    С++. move-конструкторы. Примеры использования.

102.    С++. move-присваивание. Примеры использования.

103.    С++. casts.

104.    C++. Шаблоны классов. Общий синтаксис.

105.    C++. Шаблоны функций. Общий синтаксис.

106.    C++. Шаблоны. Что может передаваться через параметры шаблонов?

107.    С++. Можно ли определять шаблоны в CPP-файле? Синтаксис.

108.    С++. placement  new

109.    C++. Как грамотно сделать аналог realloc на C++ ?

110.    C++. Идея того, как сделать, чтобы оператор [] выполнял бы разные действия слева и справа от знака присваивания.

111.    С++. Пример использования auto.

112.    C++.  initializer_list. Пример использования.

113.    Структуры данных. Чем определяется структуры данных? Общие понятия.

114.    Структура данных стек. Определение.

115.    Структура данных стек. Описать класс на С++ для реализации стека (без определения функций).

116.    Структура данных дек. Описать класс на С++ для реализации дека (без определения функций).

117.    Структура данных очередь. Описать класс на С++ для реализации очереди (без определения функций).

118.    Структура данных двунаправленный список. Описать класс на С++ для реализации двунаправленного списка (без определения функций).

119.    Структура данных однонаправленный список. Описать класс на С++ для реализации однонаправленного списка (без определения функций).

120.    Структура данных циклический список. Описать класс на С++ для реализации циклического списка (без определения функций).

121.    Идеи бессылочной реализации списка.

122.    Итераторы в стиле STL. Какие функции надо реализовать для реализации такого итератора?

123.    Итераторы в стиле STL. Написать описание класса для реализации такого итератора (без определения функций).

124.    Основные идеи реализации списка с собственным выделением памяти.

125.    Бинарные деревья. Определение дерева поиска.

126.    Бинарные деревья. Идеально-сбалансированные деревья. Определение.

127.    Бинарные деревья. Идеально-сбалансированные’ деревья. Определение.

128.    Бинарные деревья. Сбалансированные деревья. Определение.

129.    Бинарные деревья. Связь между идеально-сбалансированными, идеально-сбалансированными’ и сбалансированными  деревьями.

130.    Теорема о связи высоты и количества элементов в сбалансированном дереве. Основная идея доказательства.

131.    Бинарные деревья. Идеально-сбалансированные деревья. Нарисовать пример (в текстовом окошке).

132.    Бинарные деревья. Идеально-сбалансированные’ деревья. Нарисовать пример (в текстовом окошке).

133.    Бинарные деревья. Сбалансированные деревья. Нарисовать пример (в текстовом окошке).

134.    Бинарные деревья. Сбалансированные деревья. Описание на С++ одной вершины сбалансированного дерева.

135.    Бинарные деревья. Деревья поиска. Описание на С++ одной вершины дерева поиска.

136.    Бинарные деревья. Деревья поиска. Поиск элемента по его индексу.

137.    Бинарные деревья. Деревья поиска. Краткое описание алгоритма нахождения минимума/максимума.

138.    Бинарные деревья. Сбалансированные деревья. Краткое описание алгоритма нахождения минимума/максимума.

139.    Бинарные деревья. Деревья поиска. Краткое описание алгоритма нахождения следующего элемента.

140.    Бинарные деревья. Сбалансированные деревья. Краткое описание алгоритма нахождения следующего элемента.

141.    Бинарные деревья. Деревья поиска. Краткое описание алгоритма вставки элемента.

142.    Бинарные деревья. Сбалансированные деревья. Краткое описание алгоритма балансировки при вставке элемента (понятие вращения /``вздергивания’’ элемента можно не уточнять).

143.    Бинарные деревья. Сбалансированные деревья. Понятие поворота.

144.    Бинарные деревья. Сбалансированные деревья. Время работы алгоритма вставки элемента.

145.    Бинарные деревья. Сбалансированные деревья. Сколько поворотов требуется для вставки элемента?

146.    Бинарные деревья. Деревья поиска. Краткое описание алгоритма поиска элемента.

147.    Бинарные деревья. Деревья поиска.  Краткое описание алгоритма удаления элемента.

148.    Бинарные деревья. Сбалансированные деревья.  Краткое описание алгоритма балансировки при уничтожения элемента (понятие вращения /``вздергивания’’ элемента можно не уточнять).

149.    Бинарные деревья. Деревья поиска. Объединение деревьев со стыковочным элементом.

150.    Бинарные деревья. Деревья поиска. Объединение деревьев без стыковочного элемента.

151.    Бинарные деревья. Деревья поиска. Разбиение дерева по разбивающему элементу.

152.    Бинарные деревья. Сбалансированные деревья. Объединение деревьев со стыковочным элементом.

153.    Бинарные деревья. Сбалансированные деревья. Время работы алгоритма объединения деревьев со стыковочным элементом.

154.    Бинарные деревья. Сбалансированные деревья. Время работы алгоритма объединения деревьев без стыковочного элемента.

155.    Бинарные деревья. Сбалансированные деревья. Разбиение дерева по разбивающему элементу.

156.    Бинарные деревья. Сбалансированные деревья. Время работы алгоритма разбиения дерева по разбивающему элементу.

157.    Подход к решению задачи создания структуры данных для хранения множества непересекающихся отрезков на числовой прямой.

158.    Красно-черные деревья. Определение.

159.    Красно-черные’ деревья. Определение.

160.    Красно-черные деревья. Описание класса на языке С++ для хранения одной вершины красно-черного дерева.

161.    Красно-черные деревья. Теорема о связи количества элементов и высоте.

162.    В-деревья. Определение.

163.    В-деревья. Теорема о связи количества элементов и высоте.

164.    В-деревья. Алгоритм поиска элемента.

165.    В-деревья. Добавление элемента. Основные идеи.

166.    В-деревья. Удаление элемента. Основные идеи.

167.    В+-деревья. Определение.

168.    STL. Последовательные контейнеры.

169.    STL. Ассоциативные контейнеры.

170.    STL. vector. Основные функции. 

171.    STL. deque. Основные функции. 

172.    STL. queue. Основные функции. 

173.    STL. Когда лучше применять дек, а когда вектор (в соответствии с внутренним строением)?

174.    STL. list. Основные функции. 

175.    STL. map. Основные функции. 

176.    STL. set. Основные функции. 

177.    STL. multimap. Основные функции.

178.    STL. multiset. Основные функции. 

179.    STL. queue. Основные функции. 

180.    STL. priority_queue. Основные функции. 

181.    STL. Функциональные объекты. Общее описание реализации.

182.    STL. Функциональные объекты. Пример собственного определения.

183.    STL. Алгоритмы. Несколько примеров.

184.    Хеширование. Набор предписаний для структуры данных, основанной на хешировании.

185.    Хеширование. Простой пример хеширование для работы со строками.

186.    Хеширование. Метод многих списков. Общее описание.

187.    Хеширование. Метод многих списков. Оценка сверху на время добавление элемента.

188.    Хеширование. Метод многих списков. Оценка среднего времени на добавление элемента.

189.    Хеширование. Метод многих списков. Основные идеи удаления элемента.

190.    Хеширование. Метод многих списков. Основные идеи добавления элемента.

191.    Хеширование. Метод многих списков. Стратегия работы с подобной структурой данных для обеспечения времени выполнения основных операций = O(1). 

192.    Хеширование. Метод линейных проб. Добавление элемента.

193.    Хеширование. Метод линейных проб. Удаление элемента.

194.    Основные идеи реализации хэш-функции на основе деления.

195.    Основные идеи реализации хэш-функции на основе умножения.

196.    CRC-алгоритм проверки целостности данных на основе представления числа как многочлена с коэффициентами в поле вычетов по модулю 2. Основные идеи.

197.    Графы. Определение. Ориентированные и неориентированные графы.

198.    Графы.  Инцидентность/смежность вершин/ребер. 

199.    Графы. Теорема о графическом представлении графов в R3.

200.    Графы. Планарные графы.

201.    Графы. Теорема о существовании плоской укладки графов.

202.    Приведение неориентированного дерева к ориентированному.

203.    Теорема о существовании плоской укладки дерева.

204.    Графы. Основное утверждение, на котором строится алгоритм волны.

205.    Графы. Время работы алгоритмы волны для случая графа без кратных ребер и петель.

206.    Графы. Формула Эйлера.

207.    Оценка количества ребер и граней конечного планарного графа через количество вершин. Основные идеи доказательства.

208.    Теорема о времени работы алгоритма волны для случая планарного графа.

209.    Основное утверждение, на котором строится алгоритм Дейкстры.

210.    Простой алгоритм Дейкстры.

211.    Модифицированный алгоритм Дейкстры.

212.    Алгоритм Дейкстры для STL.

213.    Модифицированная приоритетная очередь. Основные операции.

214.    Модифицированная приоритетная очередь. Алгоритм добавления элемента.

215.    Модифицированная приоритетная очередь. Алгоритм модификации элемента.

216.    Модифицированная приоритетная очередь. Алгоритм удаления первого элемента.

217.    C/C++. Модель памяти. Стек/куча.

218.    С/С++. Оценить сколько раз можно погрузиться в рекурсию в конструкции void f(){f();}

219.    C/C++. Ограничения на размер локальных автоматических переменных.

220.    Понятия процессов/нитей.

221.    С/С++. Как реализовать функцию, которая при первом вызове делает одно действие, а при последующих – другие.

222.    С/С++. Время жизни переменных.

223.    С/С++. Область видимости переменных.

224.    С/С++. Различие во времени рождения статических переменных.

225.    С/С++. Для каких массивов существует существенное ограничение на размер?

226.    C/C++. Что такое фактические и формальные параметры функций?

227.    С/С++. Кратко о механизмах передачи параметров в функции.

228.    С/С++. Что такое goto на уровне ассемблера?

229.    С/С++. Что такое вызов функции на уровне ассемблера?

230.    С/С++. Что такое switch на уровне ассемблера?

231.    С. Как создать двумерный массив за одно отведение памяти?

## Вопросы по языку С.

1.    Арифметические операции. Оператор присваивания, как бинарный оператор, его значение.  
https://prog-cpp.ru/c-operation/  
https://ravesli.com/urok-39-arifmeticheskie-operatory/#toc-6

2.    В каком случае допустимо использование #include "mysuperlib.h"? В каком случае допустимо использование #include <mysuperlib.h>?  
https://arduinoplus.ru/include-v-cpp/  
https://ru.stackoverflow.com/questions/149/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BB%D0%B8%D1%87%D0%B8%D0%B5-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-%D0%B4%D0%B2%D1%83%D0%BC%D1%8F-%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D0%BC%D0%B8-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B-include-%D0%B2-%D0%BA%D0%B0%D0%B2%D1%8B%D1%87%D0%BA%D0%B0%D1%85-%D0%B8-%D0%B2-%D1%81%D0%BA%D0%BE%D0%B1%D0%BA%D0%B0%D1%85


3.    Директивы препроцессора: #define, #undef, #if..#else..#endif, #ifdef, #pragma once. Правила хорошего тона при оформлении оператора #define.  
http://cppstudio.com/post/5396/

4.    Директивы препроцессора: #include. Правила оформления (с помощью директив #ifdef/#define и #pragma once)  
http://cppstudio.com/post/5396/

5.    Для значений какого типа данных отводится 8 бит?  
char

6.    Какая комбинация знаков соответствует операции декрементирования?  
x--

7.    Какая комбинация знаков соответствует операции присваивания с суммированием?  
x+=

8.    Какие объекты передаются в функции в языке С по ссылке?  
которые могут изменяться. Передача по ссылке позволяет возвратить из функции сразу несколько значений. Также передача параметров по ссылке является более эффективной при передаче очень больших объектов, поскольку в этом случае не происходит копирования значений, а функция использует сам объект, а не его значение. https://metanit.com/cpp/tutorial/3.3.php

9.    Какие способы передачи параметров в функции существуют в различных языках программирования?  
по значению и по ссылке(по адресу или указателю) https://studopedia.ru/10_237326_sposobi-peredachi-parametrov-funktsiyam.html

10.   Какое значение будет иметь переменная p после выполнения операций:
 int p=3, x=6;if ((p%x)>2) p=p+x;else { if (p%2==0) p=p-x; else p=-p-x; }  
ответ: x=6 b=9

11.   Какое значение будет иметь переменная p после выполнения операций: 
int p=3;switch (p<<1) { case 2: break;    case 3: p+=1; break;  case 4: p=p+2;  default: p=0; }  
ответ: 0

12.   Какое служебное слово используется для завершения текущей итерации цикла (продолжение цикла при помощи перехода к следующей итерации)?  
continue

13.   Какое служебное слово является заголовком оператора цикла с постусловием?  
do ... while 

14.   Какое служебное слово является заголовком оператора цикла с постусловием?  
do ... while (иногда repeat ... until)

15.   Какой знак соответствует операции остаток от деления целых чисел?
%

16.   Какой знак соответствует операции получения адреса операнда?  
&

17.   Какой знак соответствует операции получения остатка от деления целочисленных операндов?  
%

18.   Какой знак соответствует операции поразрядного инвертирования внутреннего двоичного кода целочисленного аргумента (побитовое отрицание)?  
~

19.   Какой синтаксис (функциональная схема) соответствует конструкции if-else?  
https://prog-cpp.ru/c-if/

20.   Какой синтаксис соответствует конструкции do-while?  
http://cppstudio.com/post/361/

21.   Какой тип данных имеет диапазон значений 0...+255?  
unsigned char

22.   Логические операции. Выражения, воспринимаемые как логические.  
в си по стандарту принято, что 0 - ложь, остальное - истина. целые числа можно рассматривать как истину(т.е выражение равное истине). double и float сравнивать с нулем не следует, но можно.  
пример: int x=0; if(x){...}  
https://spravochnick.ru/informatika/algebra_logiki_logika_kak_nauka/logicheskie_operacii_i_ih_svoystva/

23.   Математическая библиотека. Основные функции.  
http://cppstudio.com/post/413/

24.   Математическая библиотека. Правила использования функций pow().  
double pow(      double basis,      double exponent );  
long double pow( long double basis, long double exponent );  
float pow(       float basis,       float exponent );  
double pow(      double basis,         int exponent );

25.   Математическая библиотека. Различие функции pow() на С и С++.  
double pow(      double basis,      double exponent );  
long double pow( long double basis, long double exponent );  
float pow(       float basis,       float exponent );  
double pow(      double basis,         int exponent );  
включения: math.h для С, cmath для С++  
В C++, эта функция перегружена в заголовочных файлах <complex> и <valarray> (смотреть pow комплексных чисел и pow в библиотеке массивов числовых значений).

В Си, определена только версия  функции с типами данных её параметров, — double. Другие перегруженные версии этой функции есть только в C++.

26.   Может ли прототип double sign(double); являться прототипом функции с заголовком double sign(double k)?  
да

27.   Можно ли использовать "continue" внутри оператора switch?  
он будет относиться к внешнему циклу для switch, если таковой будет.
нет, не нужно так делать https://forum.sources.ru/index.php?showtopic=365058

28.   Можно ли использовать "return" внутри оператора switch?  
да, можно внутри к-л. функции, пример https://otvet.mail.ru/question/83768059

29.   Написать функцию, рекурсивно (!) определяющую является ли целое число N точной степенью двойки. Привести пример вызова такой функции.  
https://www.cyberforum.ru/cpp-beginners/thread1442053.html

30.   Что будет выведено на экран: {int x[5]; printf(”%d”,(int)sizeof(x));}  
8 - он же размер указателя

31.   Что будет выведено на экран при вызове функции: void f(int x[5]){ printf(”%d”,(int)sizeof(x));}  
20 = 4*5 

32.   Может ли синтаксически индекс массива быть отрицательным?  
да, например  int mass[]={1, 6, 9, 2, 5};int *mass2 = &mass[3];printf("%d", mass2[-1]);

33.   Напишите выводимое значение. int mass[]={1, 6, 9, 2, 5};int *mass2 = &mass[3];printf("%d", mass2[-1]);  
ответ: 9

34.   Напишите десятичное значение «-16» в прямом двоичном коде (ответ дать в 8битном представлении).  
1001 0000 //1 под минус и значение 

35.   Напишите десятичное значение «-16» в обратном двоичном коде (ответ дать в 8битном представлении).  
1110 1111 //1 под минус и инверсия  

36.   Напишите десятичное значение «-16» в дополнительном двоичном коде (ответ дать в 8битном представлении).   
1111 0000 //обратный +1

37.   Напишите значение выражения: (!1)+(!0)+(!(-5)).  
1110 + 1111 + !(1010)= 14+15+5= 34  
для си имеем 0+1+0=1

38.   Напишите значение выражения: (!18)-(5<<2)+(6^5).  
0 - (сдвиг вправо 101) + (искл. или 6 xor 5)=0-20+3=-17  
для си, !18 = 0. для номраьного ответа, нужно инвертировать:  
(!18)-(5<<2)+(6^5) = -19-20+3=-36

39.   Напишите значение выражения: (3==5)? 3 : 5.  
5

40.   Напишите значение выражения: (4<<2)|4;  
20

41.   Напишите значение выражения:  (6&5);  
4

42.   Напишите значение выражения:  (6^5);  
3

43.   Напишите значение выражения: (5<<1)+(3!=5)  
(5<<1)+(3!=5)) = 10+1=11   
11

44.   Напишите значение выражения: (7>>1)&4;  
6
  
45.   Напишите значение выражения: 3+4>5 && 3+5>4;  
1

46.   Напишите идентификатор, определяющий действия при отсутствии нужного варианта в операторе switch?  
default

47.   Напишите идентификатор, соответствующий операции определения размера операнда?  
sizeof

48.   Напишите название базового типа данных, который указывает на целое число увеличенной длины (длинное целое).  
long int

49.   Напишите название директивы макроподстановки.  
define

50.   Напишите название директивы препроцессора определения макроса или препроцессорного идентификатора.  
define

51.   Напишите название директивы препроцессора проверки неопределённости идентификатора.  
ifndef

52.   Напишите название квалификатора, который можно использовать с базовыми типами данных для установления «короткого» целого числа.  
short

53.   Напишите название квалификатора, который можно использовать с базовыми типами данных для установления значений со знаком.  
signed

54.   Напишите название оператора, который возвращает размер в байтах переменной или типа?  
sizeof()

55.   Напишите название функции арксинуса, принадлежащей математической библиотеке.  
asin

56.   Напишите название функции записи символа в файл.  
fprintf()

57.   Напишите название функции установки произвольной позиции в файле.  
fseek(f,pos,SEEK_SET);//курсор в позицию pos от начала файла  
lseek(int handle, int pos, int whence);  
https://studopedia.su/6_52978_ustanovka-proizvolnoy-pozitsii-v-fayle.html

58.   Напишите название функции форматированного чтения из файла.  
fscanf

59.   Напишите название функции форматированного чтения из строки.  
sscanf

60.   Напишите название функции, возвращающей значение натурального логарифма  
log(a)

61.   Напишите название функции, возвращающей значение первого числа в степени второго  
pow(a,b)

62.   Напишите название функции, возвращающей наибольшее целое, не превышающее данное значение.  
floor(x)

63.   Напишите название функции, выполняющей выделение памяти и перенос в неё копию заданной строки.  
strcpy

64.   Напишите название функции, выполняющей поиск второй заданной строки в первой.  
strstr  http://all-ht.ru/inf/prog/c/func/strstr.html

65.   Напишите название функции, выполняющей сравнение заданных строк.  
strcmp

66.   Напишите название функции, выполняющей сцепление строк символов.  
strcat

67.   Напишите название функции, вычисляющей ближайшее целое, не меньшее, чем данный вещественный аргумент  
ceil

68.   Напишите название функции, считывающей один символ из файла.  
fgetc

69.   Напишите название функции, считывающей очередной символ из стандартного входного потока (stdin).  
getc, getchar

70.   Напишите последовательность символов, выводимую при выполнении кода: 
… int main () {char str[] = "12345678910"; char * pch;pch=strchr(str,'5'); printf ("%s\n", pch);return 0;}  
ответ: 5678910

71.   Напишите последовательность символов, выводимую при выполнении кода: 
… int main(void) {char s1[80], s2[80];strcpy(s1, "A1"); strcpy(s2, "B2"); strcat(s1, s2);printf("%s", s1); return 0; }  
ответ: A1B2

72.   Напишите последовательность символов, выводимую при выполнении кода: … int main(void) {int a=27;char str[] = "12345678910";printf("%2s\n", str);return 0;}  
ответ: 12345678910

73.   Напишите последовательность символов, используемую внутри printf для выведения вывода вещественного числа в поле из 7 позиций.  
%7d   https://cpp.com.ru/shildt_spr_po_c/08/0804.html

74.   Напишите последовательность символов, используемую внутри printf для выведения двойных кавычек.  
printf("My text is: \"my text\"\n");

75.   Напишите последовательность символов, используемую внутри printf для выведения строки символов.  
%s

76.   Напишите последовательность символов, используемую внутри printf для выведения табуляции.  
\t

77.   Напишите последовательность символов, используемую внутри printf для выведения указателя.  
%p or %n

78.   Напишите последовательность символов, используемую внутри printf для выведения целого десятичного числа.  
%d или %i со знаком

79.   Напишите последовательность символов, используемую внутри printf для выведения числа в экспоненциальной форме.  
%e or %E

80.   Напишите последовательность символов, используемую внутри printf для выведения числа с двойной точностью.  
%2

81.   Напишите последовательность символов, используемую внутри printf для выведения шестнадцатеричного числа.  
%x or %X   (для формата 0xh.hhhhp+d можно использовать %а, %А)

82.   Напишите последовательность символов, используемую внутри printf для печати в выводимой строке не менее 15 символов.  
%.15s

83.   Что может содержаться в include-файлах и что в C-файлах.  
Цитата: в include-файле на одну функцию отводится только одна строка. Посему, либо функция короткая и ее определение в строку вмещается на экране, либо ее надо безжалостно выносить в с/cpp-файл.  
https://ru.stackoverflow.com/questions/275741/include-%D0%B2-%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D1%85-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D1%85

84.   Операторы перехода (break, continue, goto).    
http://cppprosto.blogspot.com/2017/09/break-continue-return-goto.html  

85.   Описать случаи, когда использование оператора goto является дурным тоном и когда оно необходимо.  
выйти из нескольких циклов сразу (или выйти из цикла и пропустить операцию) - необходимо, дурной тон - когда можно заменить на for.  
http://cppprosto.blogspot.com/2017/09/break-continue-return-goto.html  
https://habr.com/ru/post/114211/

86.   Операторы условия и выбора (if, switch). Синтаксис.  
https://prog-cpp.ru/c-if/  
https://habr.com/ru/post/347132/

87.   Оператор цикла for. Синтаксис.  
https://prog-cpp.ru/c-cycles/

88.   Оператор цикла  while. Синтаксис.  
https://prog-cpp.ru/c-cycles/

89.   Оператор цикла  do-while. Синтаксис.  
https://prog-cpp.ru/c-cycles/

90.   Операция ? : . Рекурсивное использование данного оператора.  
имеется в виду использование несколько раз, например:  
return x<0?0:x<10?1:x<100?2:3  
https://purecodecpp.com/archives/554  
https://inf5.ru/cpp_lections/lection_5.htm

91.   Опишите ситуацию, в которой sizeof(x) возвращает значение, отличное от 10, в случае если x описывается как char x[10].  
размер указателя, а не массива https://ru.stackoverflow.com/questions/8574/%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-sizeof-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D1%82-%D0%BD%D0%B5-%D1%82%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5

92.   Основные скалярные типы (различные целые, вещественные).  
https://prog-cpp.ru/c-data-types/  

93.   Формат представления констант (различных целых, различных вещественных, символьных, строковых).  
https://prog-cpp.ru/c-data-types/  
https://rtfm.co.ua/books-translations/kurs-c-s-nulya/kurs-c-s-nulya-chast-5-konstanty/  
https://cpp.com.ru/shildt_spr_po_c/02/0209.html

94.   Почему при выполнении функции printf(“1”) на экране может ничего не появиться. Как исправить эту ситуацию?  
в си надо указать формат и подключить stdio  
http://citforum.ru/security/articles/printf/

95.   Работа с бинарными файлами. fopen/fclose/fread/fwrite.  
https://learnc.info/c/binary_files.html

96.   Работа с бинарными файлами. Использование функций fseek()/ftell()  
https://learnc.info/c/binary_files.html

97.   Работа с текстовыми файлами. Правила использования функции fgets().  
https://www.cyberforum.ru/cpp-beginners/thread389914.html  
https://learnc.info/c/text_files.html 

98.   Основные идеи считывание строк неограниченной длины с помощью функции fgets().  
http://www.cplusplus.com/reference/cstdio/fgets/

99.   Стандартная библиотека ввода-вывода: семейство функций printf().  
https://cpp.com.ru/shildt_spr_po_c/08/0804.html   

100.    Основные спецификации формата в функциях типа printf().  
https://cpp.com.ru/shildt_spr_po_c/08/0804.html   

101.    Стандартная библиотека ввода-вывода: семейство функций scanf().Основные спецификации формата.  
https://cpp.com.ru/shildt_spr_po_c/13/scanf.html

102.     Стандартная библиотека ввода-вывода: семейство функций scanf(). Форматы %n и [] с примерами использования.  
https://cpp.com.ru/shildt_spr_po_c/13/scanf.html

103.    Строки в языке С, принципы организации.  
https://lektsii.org/9-33975.html

104.    Функции strlen, strcat, strcpy. В том числе, что они возвращают?  
https://lektsii.org/9-33975.html  
http://all-ht.ru/inf/prog/c/func

105.    Функции strdup,strcmp, strstr, strchr. В том числе, что они возвращают?  
https://lektsii.org/9-33975.html  
http://all-ht.ru/inf/prog/c/func

106.    Указатели и массивы. Указать в каких случаях их использование дает различный результат.  
под массив придется выделять память. Фиксированный массив знает свою длину, а указатель на массив — нет.
Еще различие возникает при использовании оператора адреса &. Используя адрес указателя, мы получаем адрес памяти переменной указателя. Используя адрес массива, возвращается указатель на целый массив.  
https://ravesli.com/urok-82-ukazateli-i-massivy/  
https://cpp.com.ru/kr_cbook/ch5kr.html

107.    Функции и прототипы, оператор return.  
https://cpp.com.ru/shildt_spr_po_c/06/0608.html 

108.    Объяснить логику компилятора, не позволяющего без описания определять функции перед использованием.  
препроцессор должен найти описание в include-файле (или в начале программы после других include) и вставить его содержимое на место include-файла. поэтому компилятор ищет в этом месте описание функции.
требование компилятора скорее не к описанию, а к существованию include-файла.
https://cpp.com.ru/shildt_spr_po_c/06/0608.html  
https://server.179.ru/tasks/cpp/total/105.html

109.    Чем отличается предназначение конструкции if-else от конструкции #if-#else-#endif?  
https://alexgyver.ru/lessons/conditions/#%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B-if-else

110.    Чем отличается функция printf от функции fprintf.  
fprintf записывает форматированный текст в указанный поток вывода.  
printf эквивалентно записи fprintf(stdout, ...) и записывает форматированный текст туда,куда указывает стандартный выходной поток.

111.    Как осуществить вывод на экран с помощью функции fprintf?  
fprintf( stdout, const char * format, ... );

112.    Чем является а в выражении double *a;?  
указателем https://learnc.info/c/pointers.html

113.    Что может являться прототипом функции func?:  
а) func(x); б) void func(double); в) double func(double x); г) int fun(double x);  
б,в. статья https://cpp.com.ru/shildt_spr_po_c/06/0608.html

114.    Что появится на экране при выполнении функции printf(“%d\n”,~-2);  
1

## Вопросы по языку Python.

1.    Как запустить программу на Python?
python3 prog.py

2.    Модель памяти Python  
http://onreader.mdl.ru/MasteringConcurrencyInPython/content/Ch17.html  
https://webdevblog.ru/osnovy-upravleniya-pamyatju-v-python/

3.    Что хранится в памяти для каждой переменной в Python?  
Каждая переменная в Python действует как объект. Объекты могут быть простыми (содержащими числа, строки и т. д.) Или контейнерами (словарями, списками или пользовательскими классами). Важно: переменная в Python не хранит значение напрямую – она хранит лишь ссылку на объект.

4.    Что значит фраза a=b в Python?  
В данном примере Python не создает новый объект – он просто создает переменную a, которая ссылается на тот же объект, что и переменная b.

5.    Арифметические операции в Python.  
http://pythonicway.com/python-operators

6.    Логические операции в Python  
http://pythonicway.com/python-operators

7.    Определение функций в Python  
https://pythonru.com/osnovy/funkcii-v-python

8.    Как задаются блоки в Python?  
табуляциями

9.    Вывод на экран в Python. В том числе задание разделителей и вида завершения вывода функцией вывода.  
https://devpractice.ru/python-lesson-12-input-output-work-with-files/

10.   Открытие/закрытие файла  
myfile = open(имя-файла [, режим-доступа] [, буферизация])  
например, my_file = open("some.txt", "w") 
myfile.close();  
статья: http://pythonicway.com/python-fileio

11.   Вид оператора if…  
if test1:  
    state1  
elif test2:  
    state2  
else:  
    state3  

12.   Аналог оператора ?:  (из С) в Python.  
https://skobki.com/python-ternarnyj-uslovnyj-operator-if-or-else/  
пример:  
x, y = 25, 50  
big = x if x < y else y

13.   Исключения в Python. Пример.  
https://pythonru.com/osnovy/obrabotka-iskljuchenij-python-blok-try-except-blok-finally

14.   Подключение модулей на примере математического модуля.  
import math as m  
print(m.e)  
или так:  
from math import e, ceil as c  
print(c(4.6))   
print(e)  
https://pythonworld.ru/osnovy/rabota-s-modulyami-sozdanie-podklyuchenie-instrukciyami-import-i-from.html

15.   Оператор for  на примере разбиение строки на слова  
with open(fn, 'r') as f:
 for word in [s for s1 in f for s2 in s1.split('\n') for s3 in s2.split('\t') for s4 in s3.split(',') for s in s4.split(' ') if s!='']:
  try: ...
  except ValueError: ...

16.   Списки в Python. Функции добавления элемента в список/удаления элемента из списка.  
[]  
https://pythonworld.ru/tipy-dannyx-v-python/spiski-list-funkcii-i-metody-spiskov.html

17.   Перебор элементов списка в Python  	
for elem in list:
 print(elem)  
на всякий случай: https://webformyself.com/spiski-python-primery-comprehension-apend-sort-length-reverse/

18.   Сортировка в Python. Пример.  	
values = [2, 10, 7, 14, 50]
//Чтобы отсортировать значения в порядке убывания:
values.sort(reverse = True)  
print(values)  
//Чтобы отсортировать значения в порядке возрастания:
values.sort()  
print(values)  
обычные сортировки (алгоритмы): https://webdevblog.ru/algoritmy-sortirovki-v-python/

19.   Лямбда-функции. Пример.  
https://pythonru.com/osnovy/vse-chto-nuzhno-znat-o-lambda-funkcijah-v-python  
https://pythonru.com/uroki/lambda-funcija-uroki-po-python-dlja-nachinajushhih

20.   Кортежи.  
()  
https://pythonworld.ru/tipy-dannyx-v-python/kortezhi-tuple.html

21.   Словари  
{}  
https://pythonru.com/osnovy/python-dict

22.   Использование кортежей в качестве индексов для словарей  
directory[last,first] = number  
//Внутри скобок выражение является кортежем.  
//Мы могли бы использовать присваивание кортежей в цикле 
for last, first in directory:  
 print first, last, directory[last, first]   
ссылка: https://webformyself.com/kortezhi-python-upakovka-raspakovka-sravnenie/
 
